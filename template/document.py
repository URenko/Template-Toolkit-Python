import cStringIO
import os
import re
import tempfile

from template import base, config, constants, iterator, util


ERROR = None

PYEVAL_NAMESPACE = {
  "scalar":    util.PerlScalar,
  "Buffer":    util.StringBuffer,
  "Error":     base.Exception,
  "Iterator":  iterator.Create,
  "Regex":     re.compile,
  "List":      util.ScalarList,
  "Dict":      util.ScalarDictionary,
  "Switch":    util.SwitchList,
  "Concat":    util.Concatenate,
  "Continue":  util.Continue,
  "Break":     util.Break,
  "Evaluate":  util.EvaluateCode,
  }

class Document(base.Base):
  def __init__(self, doc):
    base.Base.__init__(self)

    #evaluate Python code in block to create sub-routine reference if necessary
    self._BLOCK = self.__evaluate(doc.get("BLOCK"))

    # same for any additional BLOCK definitions
    self._DEFBLOCKS = {}
    for name, block in doc.get("DEFBLOCKS", {}).iteritems():
      self._DEFBLOCKS[name] = self.__evaluate(block)

    self._META = doc.get("METADATA", {}).copy()
    self._HOT = 0

  def __evaluate(self, block, debug=False):
    if callable(block):
      return block
    namespace = PYEVAL_NAMESPACE.copy()
    if debug:
      print block
    try:
      exec block in namespace
    except base.Exception, e:
      return self.error(e)
    return namespace["block"]

  def __getattr__(self, name):
    if name and name[0].islower():
      return self._META.get(name)
    else:
      raise AttributeError(name)

  def block(self):
    return self._BLOCK

  def blocks(self):
    return self._DEFBLOCKS

  def process(self, context):
    if self._HOT and not context.recursion():
      return context.throw(constants.ERROR_FILE,
                           "recursion into '%s'" % self.name)
    context.visit(self, self._DEFBLOCKS)
    self._HOT = 1
    try:
      try:
        output = self._BLOCK(context)
      except base.Exception, e:
        raise context.catch(e)
    finally:
      self._HOT = 0
      context.leave()
    return output

  @classmethod
  def write_python_doc(cls, fh, content):
    fh.write("# Compiled template generated by the Template Toolkit\n\n")
    fh.write("metadata = %r\n\n" % content.get("METADATA"))
    fh.write("blocks = {}\n\n")
    for name, code in sorted(content.get("DEFBLOCKS", {}).iteritems()):
      fh.write(code)
      fh.write("\nblocks[%r] = block\n\n" % name)
    fh.write(content["BLOCK"])
    fh.write("\ndocument = Document({'METADATA': metadata, "
             "'DEFBLOCKS': blocks, 'BLOCK': block})\n")

  @classmethod
  def write_python_file(cls, file, content):
    if not file:
      return cls.Error("invalid null filename")
    try:
      tmpfh, tmppath = tempfile.mkstemp(dir=os.path.dirname(file))
      tmpfh = os.fdopen(tmpfh, "w")
      cls.write_python_doc(tmpfh, content)
      tmpfh.close()
      os.rename(tmppath, file)
      return True
    except EnvironmentError, e:
      return cls.Error(e)
